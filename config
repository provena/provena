#!/usr/bin/env bash
# This script was generated by bashly 1.1.9 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  #!/bin/bash

  # Initialize global variables and perform setup tasks
  initialize() {
    set -e  # Exit immediately if a command exits with a non-zero status
    # Set DEBUG flag if environment variable is set to 'true'
    [[ "${DEBUG}" == "true" ]] && set -x
    # Initialize variables
    TEMP_DIR=""
    ENV_FILE="env.json"
    BASE_STAGE="base"
    DEFAULT_BRANCH="main"

    # Ensure jq is installed
    if ! command -v jq &> /dev/null; then
      echo "Error: jq is required but not installed. Please install jq and try again."
      exit 1
    fi
  }

  # Read the default target repository from env.json
  read_default_target() {
    if [[ -f "$ENV_FILE" ]]; then
      jq -r ".$NAMESPACE.$STAGE // empty" "$ENV_FILE"
    fi
  }

  # Update or create env.json with the new target repository
  update_env_file() {
    local target="$1"
    if [[ -f "$ENV_FILE" ]]; then
      # Update existing file
      jq --arg ns "$NAMESPACE" --arg stage "$STAGE" --arg target "$target" \
        '.[$ns][$stage] = $target' "$ENV_FILE" > "${ENV_FILE}.tmp" && mv "${ENV_FILE}.tmp" "$ENV_FILE"
    else
      # Create new file
      jq -n --arg ns "$NAMESPACE" --arg stage "$STAGE" --arg target "$target" \
        '{($ns): {($stage): $target}}' > "$ENV_FILE"
    fi
  }

  # Clone the target repository into a temporary directory
  clone_repo() {
    TEMP_DIR=$(mktemp -d)
    echo "Cloning repository into temporary directory: $TEMP_DIR"
    git clone -b "$BRANCH" "$TARGET_REPO" "$TEMP_DIR"
  }

  # Copy files from the cloned repository to the local workspace
  copy_files() {
    local source_dir="$1"
    local stage="$2"

    if [[ -d "$source_dir/$NAMESPACE/$stage" ]]; then
      echo "Copying files from $source_dir/$NAMESPACE/$stage to current directory"
      cp -R "$source_dir/$NAMESPACE/$stage"/* .
    else
      echo "Warning: Directory $source_dir/$NAMESPACE/$stage does not exist. Skipping."
    fi
  }

  # Copy both base and specified stage files
  copy_all_files() {
    local source_dir="$1"

    # Copy base files first
    copy_files "$source_dir" "$BASE_STAGE"

    # Copy specified stage files, potentially overwriting base files
    if [[ "$STAGE" != "$BASE_STAGE" ]]; then
      copy_files "$source_dir" "$STAGE"
    fi
  }

  # Clean up temporary directory
  cleanup() {
    if [[ -n "$TEMP_DIR" && -d "$TEMP_DIR" ]]; then
      echo "Cleaning up temporary directory: $TEMP_DIR"
      rm -rf "$TEMP_DIR"
    fi
  }

  # Validate command-line arguments and set global variables
  validate_args() {
    # Validate namespace and stage
    if [[ -z "${args[namespace]}" || -z "${args[stage]}" ]]; then
      echo "Error: Both namespace and stage must be specified."
      exit 1
    fi
    # Set global variables based on command-line arguments
    NAMESPACE="${args[namespace]}"
    STAGE="${args[stage]}"
    TARGET_REPO="${args[--target]}"
    REPO_DIR="${args[--repo-dir]}"
    BRANCH="${args[--branch]:-$DEFAULT_BRANCH}"
    # Check if either --target or --repo-dir is provided
    if [[ -n "$TARGET_REPO" && -n "$REPO_DIR" ]]; then
      echo "Error: Cannot specify both --target and --repo-dir."
      exit 1
    elif [[ -z "$TARGET_REPO" && -z "$REPO_DIR" ]]; then
      # If neither is provided, check env file for default values
      TARGET_REPO=$(read_default_target)
      if [[ -z "$TARGET_REPO" ]]; then
        echo "Error: No target repository specified, no --repo-dir provided, and no default found in $ENV_FILE"
        exit 1
      else
        echo "Using default target repository from $ENV_FILE"
      fi
    fi
  }

  initialize
  validate_args

  if [[ -n "$REPO_DIR" ]]; then
    # Use pre-cloned repository
    if [[ ! -d "$REPO_DIR" ]]; then
      echo "Error: Specified repo directory does not exist: $REPO_DIR"
      exit 1
    fi
    copy_all_files "$REPO_DIR"
  else
    # Use target repository (either specified or from env.json)
    clone_repo
    copy_all_files "$TEMP_DIR"
    update_env_file "$TARGET_REPO"
    cleanup
  fi

  echo "Configuration update complete for namespace: $NAMESPACE, stage: $STAGE, branch: $BRANCH"
}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
config_usage() {
  if [[ -n $long_usage ]]; then
    printf "config - Configuration management tool for interacting with a private configuration repository\n"
    echo

  else
    printf "config - Configuration management tool for interacting with a private configuration repository\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  config NAMESPACE STAGE [OPTIONS]\n"
  printf "  config --help | -h\n"
  printf "  config --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--target, -t REPO_CLONE_STRING"
    printf "    The repository clone string\n"
    echo

    # :flag.usage
    printf "  %s\n" "--repo-dir, -d PATH"
    printf "    Path to the pre-cloned repository\n"
    echo

    # :flag.usage
    printf "  %s\n" "--branch, -b BRANCH_NAME"
    printf "    The branch to clone from the remote config repository (default: 'main')\n"
    printf "    Default: main\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAMESPACE"
    printf "    The namespace to use (e.g., 'rrap')\n"
    echo

    # :argument.usage
    printf "  %s\n" "STAGE"
    printf "    The stage to use (e.g., 'dev', 'stage')\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "DEBUG"
    printf "    Set to 'true' for verbose output\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        config_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("DEBUG")

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --target | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--target']="$2"
          shift
          shift
        else
          printf "%s\n" "--target requires an argument: --target, -t REPO_CLONE_STRING" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --repo-dir | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--repo-dir']="$2"
          shift
          shift
        else
          printf "%s\n" "--repo-dir requires an argument: --repo-dir, -d PATH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --branch | -b)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--branch']="$2"
          shift
          shift
        else
          printf "%s\n" "--branch requires an argument: --branch, -b BRANCH_NAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['namespace']+x} ]]; then
          args['namespace']=$1
          shift
        # :argument.case
        elif [[ -z ${args['stage']+x} ]]; then
          args['stage']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['namespace']+x} ]]; then
    printf "missing required argument: NAMESPACE\nusage: config NAMESPACE STAGE [OPTIONS]\n" >&2
    exit 1
  fi
  if [[ -z ${args['stage']+x} ]]; then
    printf "missing required argument: STAGE\nusage: config NAMESPACE STAGE [OPTIONS]\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--branch']:-} ]] || args['--branch']="main"

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

initialize
run "$@"
