#!/usr/bin/env bash
# This script was generated by bashly 1.1.9 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
fb_usage() {
  if [[ -n $long_usage ]]; then
    printf "fb - Set of Bash CLI tools which helps automate feature branch deployments.\n"
    echo

  else
    printf "fb - Set of Bash CLI tools which helps automate feature branch deployments.\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  fb COMMAND\n"
  printf "  fb [COMMAND] --help | -h\n"
  printf "  fb --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Setup the feature branch using the standard name.\n" "branch   "
  printf "  %s   Deploys the pipeline cloudformation Stack for the current git branch. Relies on feat.json or feat-ui.json being available in config.\n" "deploy   "
  printf "  %s   Sets up the APIs with .env files which reflect the deployed feature infrastructure configurations. Requires complete deployment, browser for auth flow, and admin permissions. Must NOT be a UI only deployment.\n" "bootstrap"
  printf "  %s   Describes the outputs and endpoints of the current feature branch in markdown format\n" "markdown "
  printf "  %s   Describes the outputs and endpoints of the current feature branch in standard non markdown format\n" "desc     "
  printf "  %s   Destroys the feature infrastructure for the given ticket and description. Run multiple times if required due to API limits. Relies on feat.json or feat-ui.json being available in config.\n" "destroy  "
  printf "  %s   Run the given commands in the context of the feature branch on either the app or pipeline stacks. All postfixed CDK commands are run. Relies on feat.json or feat-ui.json being available in config.\n" "run      "
  printf "  %s   Runs a CDK hotswap deploy on the current deployed app infrastructure. Relies on feat.json or feat-ui.json being available in config.\n" "hotswap  "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
fb_branch_usage() {
  if [[ -n $long_usage ]]; then
    printf "fb branch - Setup the feature branch using the standard name.\n"
    echo

  else
    printf "fb branch - Setup the feature branch using the standard name.\n"
    echo

  fi

  printf "Alias: b\n"
  echo

  printf "%s\n" "Usage:"
  printf "  fb branch TICKET NAME [BASE]\n"
  printf "  fb branch --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TICKET"
    printf "    The JIRA ticket number (or identifier)\n"
    echo

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    A helpful name in the style some-feat-description\n"
    echo

    # :argument.usage
    printf "  %s\n" "BASE"
    printf "    The bash branch to branch from - defaults to main\n"
    printf "    Default: main\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  fb branch 1234 awesome-feature\n"
    printf "  fb branch 1234 awesome-feature other-base-branch\n"
    echo

  fi
}

# :command.usage
fb_deploy_usage() {
  if [[ -n $long_usage ]]; then
    printf "fb deploy - Deploys the pipeline cloudformation Stack for the current git branch. Relies on feat.json or feat-ui.json being available in config.\n"
    echo

  else
    printf "fb deploy - Deploys the pipeline cloudformation Stack for the current git branch. Relies on feat.json or feat-ui.json being available in config.\n"
    echo

  fi

  printf "Alias: d\n"
  echo

  printf "%s\n" "Usage:"
  printf "  fb deploy [OPTIONS]\n"
  printf "  fb deploy --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ui_only, -u"
    printf "    Only deploy UIs - runs against DEV infrastructure. Depends on feat-ui.json\n    being available for config!\n"
    echo

    # :flag.usage
    printf "  %s\n" "--notify, -n"
    printf "    Enables pipeline alerts on Teams channel\n"
    echo

    # :flag.usage
    printf "  %s\n" "--monitoring, -m"
    printf "    Enables sentry monitoring\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  fb d\n"
    printf "  fb d -u -n\n"
    echo

  fi
}

# :command.usage
fb_bootstrap_usage() {
  if [[ -n $long_usage ]]; then
    printf "fb bootstrap - Sets up the APIs with .env files which reflect the deployed feature infrastructure configurations. Requires complete deployment, browser for auth flow, and admin permissions. Must NOT be a UI only deployment.\n"
    echo

  else
    printf "fb bootstrap - Sets up the APIs with .env files which reflect the deployed feature infrastructure configurations. Requires complete deployment, browser for auth flow, and admin permissions. Must NOT be a UI only deployment.\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  fb bootstrap\n"
  printf "  fb bootstrap --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  fb bootstrap\n"
    echo

  fi
}

# :command.usage
fb_markdown_usage() {
  if [[ -n $long_usage ]]; then
    printf "fb markdown - Describes the outputs and endpoints of the current feature branch in markdown format\n"
    echo

  else
    printf "fb markdown - Describes the outputs and endpoints of the current feature branch in markdown format\n"
    echo

  fi

  printf "Alias: md\n"
  echo

  printf "%s\n" "Usage:"
  printf "  fb markdown [OPTIONS]\n"
  printf "  fb markdown --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ui_only, -u"
    printf "    UI Only dump - doesn't include APIs - just UIs\n"
    echo

    # :flag.usage
    printf "  %s\n" "--url URL (required)"
    printf "    The base URL to use e.g. dev.domain.com\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  fb md --url your.domain.com\n"
    printf "  fb md -u --url your.domain.com\n"
    printf "  fb md -u --url your.domain.com\n"
    echo

  fi
}

# :command.usage
fb_desc_usage() {
  if [[ -n $long_usage ]]; then
    printf "fb desc - Describes the outputs and endpoints of the current feature branch in standard non markdown format\n"
    echo

  else
    printf "fb desc - Describes the outputs and endpoints of the current feature branch in standard non markdown format\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  fb desc [OPTIONS]\n"
  printf "  fb desc --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ui_only, -u"
    printf "    UI Only dump - doesn't include APIs - just UIs\n"
    echo

    # :flag.usage
    printf "  %s\n" "--url URL"
    printf "    The base URL to use e.g. dev.domain.com\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  fb desc --url your.domain.com\n"
    printf "  fb desc -u --url your.domain.com\n"
    printf "  fb desc -u --url your.domain.com\n"
    echo

  fi
}

# :command.usage
fb_destroy_usage() {
  if [[ -n $long_usage ]]; then
    printf "fb destroy - Destroys the feature infrastructure for the given ticket and description. Run multiple times if required due to API limits. Relies on feat.json or feat-ui.json being available in config.\n"
    echo

  else
    printf "fb destroy - Destroys the feature infrastructure for the given ticket and description. Run multiple times if required due to API limits. Relies on feat.json or feat-ui.json being available in config.\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  fb destroy TICKET NAME [OPTIONS]\n"
  printf "  fb destroy --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ui_only, -u"
    printf "    This flag should be included if the feature branch was UI only. Relies on\n    feat-ui.json being available in configs!\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TICKET"
    printf "    The JIRA ticket number (or identifier)\n"
    echo

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    The chosen feature description - must match deployed feature\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  fb destroy 1234 awesome-feature\n"
    printf "  fb destroy 1234 awesome-feature -u\n"
    echo

  fi
}

# :command.usage
fb_run_usage() {
  if [[ -n $long_usage ]]; then
    printf "fb run - Run the given commands in the context of the feature branch on either the app or pipeline stacks. All postfixed CDK commands are run. Relies on feat.json or feat-ui.json being available in config.\n"
    echo

  else
    printf "fb run - Run the given commands in the context of the feature branch on either the app or pipeline stacks. All postfixed CDK commands are run. Relies on feat.json or feat-ui.json being available in config.\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  fb run TARGET [OPTIONS] [...]\n"
  printf "  fb run --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ui_only, -u"
    printf "    This flag should be included if the feature branch was UI only. This will\n    avoid building the full application stacks against a deployed UI only stack.\n    Relies on feat-ui.json config being available.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TARGET"
    printf "    app = The actual application stack, pipeline = The pipelines stack\n"
    printf "    Allowed: app, pipeline\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  fb run app deploy --hotswap\n"
    printf "  fb run app --ui_only deploy --hotswap\n"
    printf "  fb run app diff\n"
    printf "  fb run app deploy\n"
    printf "  fb run pipeline diff\n"
    printf "  fb run pipeline deploy\n"
    echo

  fi
}

# :command.usage
fb_hotswap_usage() {
  if [[ -n $long_usage ]]; then
    printf "fb hotswap - Runs a CDK hotswap deploy on the current deployed app infrastructure. Relies on feat.json or feat-ui.json being available in config.\n"
    echo

  else
    printf "fb hotswap - Runs a CDK hotswap deploy on the current deployed app infrastructure. Relies on feat.json or feat-ui.json being available in config.\n"
    echo

  fi

  printf "Alias: hot\n"
  echo

  printf "%s\n" "Usage:"
  printf "  fb hotswap [OPTIONS]\n"
  printf "  fb hotswap --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ui_only, -u"
    printf "    This flag should be included if the feature branch was UI only. Relies on\n    feat-ui.json being available in config.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  fb hot\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.command_functions
# :command.function
fb_branch_command() {
  # src/branch_command.sh
  #!/usr/bin/env bash -e

  ticket_number=${args[ticket]}
  feature_desc=${args[name]}
  base_branch=${args[base]}

  # branch name
  branch_name="feat-${ticket_number}-${feature_desc}"

  git checkout ${base_branch}
  git pull
  git checkout -b ${branch_name}
  git push --set-upstream origin ${branch_name}

  echo "Created and published feature branch ${branch_name} based on ${base_branch}. Use fb deploy to deploy the sandbox infrastructure for this feature branch."

}

# :command.function
fb_deploy_command() {
  # src/deploy_command.sh
  #!/usr/bin/env bash -e

  python_command="python3.10"

  # get the current branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)

  # split branch on hyphens
  IFS='-'
  branch_split=($current_branch)
  unset IFS

  # check that the second number is okay
  ticket_number=${branch_split[1]}

  stack_prefix="f${ticket_number}"

  main_branches=("main" "test" "stage" "prod")

  pipeline_link_q_string=$(echo "{\"f\":{\"text\":\"${stack_prefix}\"},\"s\":{\"property\":\"updated\",\"direction\":-1},\"n\":10,\"i\":0}" | base64 -w 0)
  pipeline_link="https://ap-southeast-2.console.aws.amazon.com/codesuite/codepipeline/pipelines?region=ap-southeast-2&pipelines-meta=${pipeline_link_q_string}"

  for b_name in "${main_branches[@]}"; do
  	# check it isn't a main branch
  	if [ ${current_branch} == ${b_name} ]; then
  		echo "Cannot deploy a feature branch from primary branch ${b_name}."
  		exit 1
  	fi
  done

  # check with user
  echo "Deploying from current branch ${current_branch}."
  read -p "Is this correct? (yY)" -n 1 -r
  echo

  if [[ $REPLY =~ ^[Yy]$ ]]; then
  	echo "Continuing"
  else
  	echo "Aborting"
  	exit 1
  fi

  # check with user
  echo "Parsed the ticket number as ${ticket_number}."
  read -p "Is this correct? (yY)" -n 1 -r
  echo

  if [[ $REPLY =~ ^[Yy]$ ]]; then
  	echo "Continuing"
  else
  	echo "Aborting"
  	exit 1
  fi

  echo "Exporting ticket number and branch name"
  export TICKET_NUMBER=${ticket_number}
  export BRANCH_NAME=${current_branch}

  echo "Moving into infrastructure folder"
  echo

  # move into infra folder
  cd infrastructure

  echo "Checking cdk install"
  echo

  # check that cdk is working
  cdk --version

  echo "Checking AWS CLI install"
  echo

  # check that AWS CLI seems to be working
  aws sts get-caller-identity

  echo "Creating python venv"
  echo

  # create a virtual environment
  ${python_command} -m venv .venv

  echo "Sourcing venv"
  echo

  # source and install requirements
  source .venv/bin/activate

  echo "Installing requirements"
  echo

  pip install -r requirements.txt

  echo "Running CDK deploy of pipeline with feature configuration"
  echo

  unset PIPELINE_ALERTS
  if [ ${args[--notify]} ]; then
  	echo "Enabling pipeline alerts"
  	export PIPELINE_ALERTS="true"
  fi

  unset ENABLE_API_MONITORING
  if [ ${args[--monitoring]} ]; then
  	echo "Enabling API monitoring via Sentry"
  	export ENABLE_API_MONITORING="true"
  fi

  stage_arg="feat"
  if [ ${args[--ui_only]} ]; then
  	echo "Performing a UI Only deployment"
  	stage_arg="feat-ui"
  fi

  # run the helper script to deploy feature branch
  echo "Running helper function: 'python app_run.py ${stage_arg} pipeline deploy --require-approval never'"
  python app_run.py ${stage_arg} pipeline "deploy --require-approval never"

  echo "Pipeline deploy completed, monitor and update deployment from ${pipeline_link} on the BUILD account."

}

# :command.function
fb_bootstrap_command() {
  # src/bootstrap_command.sh
  #!/usr/bin/env bash -e

  python_command="python3.10"

  # get the current branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)

  # split branch on hyphens
  IFS='-'
  branch_split=($current_branch)
  unset IFS

  # check that the second number is okay
  ticket_number=${branch_split[1]}

  # move into the env bootstrapper location
  echo "Moving to environment bootstrapper tool"
  echo

  cd admin-tooling/environment-bootstrapper

  echo "Creating python venv"
  echo

  # create a virtual environment
  ${python_command} -m venv .venv

  echo "Sourcing venv"
  echo

  # source and install requirements
  source .venv/bin/activate

  echo "Installing requirements"
  echo

  pip install -r requirements.txt

  echo "Running bootstrap operation with feature branch number ${ticket_number}"
  echo

  # run the helper script to deploy feature branch
  python environment_bootstrapper.py bootstrap-stage feature --suppress-warnings --param feature_number:${ticket_number}

  echo "Bootstrapping complete."

}

# :command.function
fb_markdown_command() {
  # src/markdown_command.sh
  #!/usr/bin/env bash -e

  python_command="python3.10"

  # get the current branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)

  # split branch on hyphens
  IFS='-'
  branch_split=($current_branch)
  unset IFS

  # check that the second number is okay
  ticket_number=${branch_split[1]}

  # from https://stackoverflow.com/questions/1527049/how-can-i-join-elements-of-an-array-in-bash
  function join_by {
  	local IFS="$1"
  	shift
  	echo "$*"
  }

  feat_desc=$(join_by - "${branch_split[@]:2}")

  main_branches=("main" "test" "stage" "prod")

  pipeline_link_q_string=$(echo "{\"f\":{\"text\":\"f${ticket_number}\"},\"s\":{\"property\":\"updated\",\"direction\":-1},\"n\":10,\"i\":0}" | base64 -w 0)
  pipeline_link="https://ap-southeast-2.console.aws.amazon.com/codesuite/codepipeline/pipelines?region=ap-southeast-2&pipelines-meta=${pipeline_link_q_string}"

  general_prefix="https://"
  base_url=${args[--url]}
  general_postfix=".${base_url}/"

  url_prefix="f${ticket_number}"

  if [ ${args[--ui_only]} ]; then
  	names=("landing-portal" "data-store-ui" "prov-ui" "registry-ui")
  	postfixes=("" "-data" "-prov" "-registry")
  else
  	names=("landing-portal" "job-api" "data-store-api" "data-store-ui" "auth-api" "prov-api" "prov-ui" "registry-api" "registry-ui")
  	postfixes=("" "-job-api" "-data-api" "-data" "-auth-api" "-prov-api" "-prov" "-registry-api" "-registry")
  fi

  echo "Feature branch name: **${current_branch}**"
  echo

  if [ ${args[--ui_only]} ]; then
  	echo "**UI Only Deployment**"
  	echo
  fi

  echo "URL Prefix: ${url_prefix}"
  echo

  echo "Pipeline links: [pipelines](${pipeline_link})"
  echo

  echo "Deployed components:"
  echo
  for index in "${!names[@]}"; do
  	name=${names[$index]}
  	postfix=${postfixes[$index]}

  	echo "[$name](${general_prefix}${url_prefix}${postfix}${general_postfix})"
  	echo
  done

  if [ ${args[--ui_only]} ]; then
  	ui_only_arg=" --ui_only "
  else
  	ui_only_arg=" "
  fi

  echo "To tear down feature deployment: ./fb destroy${ui_only_arg}${ticket_number} ${feat_desc}"

}

# :command.function
fb_desc_command() {
  # src/desc_command.sh
  #!/usr/bin/env bash -e

  python_command="python3.10"

  # get the current branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)

  # split branch on hyphens
  IFS='-'
  branch_split=($current_branch)
  unset IFS

  # check that the second number is okay
  ticket_number=${branch_split[1]}

  # from https://stackoverflow.com/questions/1527049/how-can-i-join-elements-of-an-array-in-bash
  function join_by {
  	local IFS="$1"
  	shift
  	echo "$*"
  }

  feat_desc=$(join_by - "${branch_split[@]:2}")

  main_branches=("main" "test" "stage" "prod")

  pipeline_link_q_string=$(echo "{\"f\":{\"text\":\"f${ticket_number}\"},\"s\":{\"property\":\"updated\",\"direction\":-1},\"n\":10,\"i\":0}" | base64 -w 0)
  pipeline_link="https://ap-southeast-2.console.aws.amazon.com/codesuite/codepipeline/pipelines?region=ap-southeast-2&pipelines-meta=${pipeline_link_q_string}"

  general_prefix="https://"
  base_url=${args[--url]}
  general_postfix=".${base_url}/"

  url_prefix="f${ticket_number}"

  if [ ${args[--ui_only]} ]; then
  	names=("landing-portal" "data-store-ui" "prov-ui" "registry-ui")
  	postfixes=("" "-data" "-prov" "-registry")
  else
  	names=("landing-portal" "data-store-api" "job-api" "data-store-ui" "auth-api" "prov-api" "prov-ui" "registry-api" "registry-ui")
  	postfixes=("" "-data-api" "-job-api" "-data" "-auth-api" "-prov-api" "-prov" "-registry-api" "-registry")
  fi

  echo "Feature branch name: ${current_branch}"
  echo

  if [ ${args[--ui_only]} ]; then
  	echo "**UI Only Deployment**"
  	echo
  fi

  echo "URL Prefix: ${url_prefix}"
  echo

  echo "Pipeline links: ${pipeline_link}"
  echo

  echo "Deployed components:"
  echo
  for index in "${!names[@]}"; do
  	name=${names[$index]}
  	postfix=${postfixes[$index]}

  	echo "${name}: ${general_prefix}${url_prefix}${postfix}${general_postfix}"
  	echo
  done

  if [ ${args[--ui_only]} ]; then
  	ui_only_arg=" --ui_only "
  else
  	ui_only_arg=" "
  fi

  echo "To tear down feature deployment: ./fb destroy${ui_only_arg}${ticket_number} ${feat_desc}"

}

# :command.function
fb_destroy_command() {
  # src/destroy_command.sh
  #!/usr/bin/env bash -e

  # decode args
  ticket_number=${args[ticket]}
  feature_desc=${args[name]}
  branch_name="feat-${ticket_number}-${feature_desc}"

  python_command="python3.10"

  # check with user
  echo "Deleting app and pipeline stack for feature branch: ${branch_name}."
  read -p "Is this correct? (yY)" -n 1 -r
  echo

  if [[ $REPLY =~ ^[Yy]$ ]]; then
  	echo "Continuing"
  else
  	echo "Aborting"
  	exit 1
  fi

  echo "Exporting ticket number and branch name"
  export TICKET_NUMBER=${ticket_number}
  export BRANCH_NAME=${current_branch}

  echo "Moving into infrastructure folder"
  echo

  # move into infra folder
  cd infrastructure

  echo "Checking cdk install"
  echo

  # check that cdk is working
  cdk --version

  echo "Checking AWS CLI install"
  echo

  # check that AWS CLI seems to be working
  aws sts get-caller-identity

  echo "Creating python venv"
  echo

  # create a virtual environment
  ${python_command} -m venv .venv

  echo "Sourcing venv"
  echo

  # source and install requirements
  source .venv/bin/activate

  echo "Installing requirements"
  echo

  pip install -r requirements.txt

  stage_arg="feat"
  if [ ${args[--ui_only]} ]; then
  	echo "Performing a UI Only destroy"
  	stage_arg="feat-ui"
  fi

  echo "Running CDK destroy of app with feature configuration"
  echo

  echo "Running helper function: 'python app_run.py ${stage_arg} app destroy --require-approval never'"
  python app_run.py ${stage_arg} app "destroy --require-approval never"

  echo "Running CDK destroy of pipeline with feature configuration"
  echo

  echo "Running helper function: 'python app_run.py ${stage_arg} pipeline destroy --require-approval never'"
  python app_run.py ${stage_arg} pipeline "destroy --require-approval never"

  echo "Pipeline and app destroy completed."

}

# :command.function
fb_run_command() {
  # src/run_command.sh
  #!/usr/bin/env bash -e

  stack_type=${args[target]}
  commands=${other_args[*]}

  python_command="python3.10"

  # get the current branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)

  # split branch on hyphens
  IFS='-'
  branch_split=($current_branch)
  unset IFS

  # check that the second number is okay
  ticket_number=${branch_split[1]}

  main_branches=("main" "test" "stage" "prod")

  for b_name in "${main_branches[@]}"; do
  	# check it isn't a main branch
  	if [ ${current_branch} == ${b_name} ]; then
  		echo "Cannot deploy a feature branch from primary branch ${b_name}."
  		exit 1
  	fi
  done

  # check with user
  echo "Running commands from current branch ${current_branch}."
  read -p "Is this correct? (yY)" -n 1 -r
  echo

  if [[ $REPLY =~ ^[Yy]$ ]]; then
  	echo "Continuing"
  else
  	echo "Aborting"
  	exit 1
  fi

  # check with user
  echo "Parsed the ticket number as ${ticket_number}."
  read -p "Is this correct? (yY)" -n 1 -r
  echo

  if [[ $REPLY =~ ^[Yy]$ ]]; then
  	echo "Continuing"
  else
  	echo "Aborting"
  	exit 1
  fi

  echo "Exporting ticket number and branch name"
  export TICKET_NUMBER=${ticket_number}
  export BRANCH_NAME=${current_branch}

  echo "Moving into infrastructure folder"
  echo

  # move into infra folder and running helper
  cd infrastructure

  echo "Creating python venv"
  echo

  # create a virtual environment
  ${python_command} -m venv .venv

  echo "Sourcing venv"
  echo

  # source and install requirements
  source .venv/bin/activate

  echo "Installing requirements"
  echo

  pip install -r requirements.txt

  echo "Running cdk on ${stack_type} with commands ${commands}..."

  stage_arg="feat"
  if [ ${args[--ui_only]} ]; then
  	echo "Performing a UI Only deployment"
  	stage_arg="feat-ui"
  fi

  # run the helper script
  python app_run.py ${stage_arg} ${stack_type} "${commands}"

}

# :command.function
fb_hotswap_command() {
  # src/hotswap_command.sh
  #!/usr/bin/env bash -e

  if [ ${args[--ui_only]} ]; then
  	ui_only_arg="--ui_only"
  else
  	ui_only_arg=""
  fi

  echo "./fb run app ${ui_only_arg} deploy --hotswap"

  ./fb run app ${ui_only_arg} deploy --hotswap

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        fb_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    branch | b)
      action="branch"
      shift
      fb_branch_parse_requirements "$@"
      shift $#
      ;;

    deploy | d)
      action="deploy"
      shift
      fb_deploy_parse_requirements "$@"
      shift $#
      ;;

    bootstrap)
      action="bootstrap"
      shift
      fb_bootstrap_parse_requirements "$@"
      shift $#
      ;;

    markdown | md)
      action="markdown"
      shift
      fb_markdown_parse_requirements "$@"
      shift $#
      ;;

    desc)
      action="desc"
      shift
      fb_desc_parse_requirements "$@"
      shift $#
      ;;

    destroy)
      action="destroy"
      shift
      fb_destroy_parse_requirements "$@"
      shift $#
      ;;

    run)
      action="run"
      shift
      fb_run_parse_requirements "$@"
      shift $#
      ;;

    hotswap | hot)
      action="hotswap"
      shift
      fb_hotswap_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      fb_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
fb_branch_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        fb_branch_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="branch"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['ticket']+x} ]]; then
          args['ticket']=$1
          shift
        # :argument.case
        elif [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        # :argument.case
        elif [[ -z ${args['base']+x} ]]; then
          args['base']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['ticket']+x} ]]; then
    printf "missing required argument: TICKET\nusage: fb branch TICKET NAME [BASE]\n" >&2
    exit 1
  fi
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: fb branch TICKET NAME [BASE]\n" >&2
    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['base']:-} ]] || args['base']="main"

}

# :command.parse_requirements
fb_deploy_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        fb_deploy_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="deploy"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ui_only | -u)

        # :flag.case_no_arg
        args['--ui_only']=1
        shift
        ;;

      # :flag.case
      --notify | -n)

        # :flag.case_no_arg
        args['--notify']=1
        shift
        ;;

      # :flag.case
      --monitoring | -m)

        # :flag.case_no_arg
        args['--monitoring']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
fb_bootstrap_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        fb_bootstrap_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bootstrap"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
fb_markdown_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        fb_markdown_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="markdown"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ui_only | -u)

        # :flag.case_no_arg
        args['--ui_only']=1
        shift
        ;;

      # :flag.case
      --url)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--url']="$2"
          shift
          shift
        else
          printf "%s\n" "--url requires an argument: --url URL" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--url']+x} ]]; then
    printf "missing required flag: --url URL\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
fb_desc_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        fb_desc_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="desc"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ui_only | -u)

        # :flag.case_no_arg
        args['--ui_only']=1
        shift
        ;;

      # :flag.case
      --url)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--url']="$2"
          shift
          shift
        else
          printf "%s\n" "--url requires an argument: --url URL" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
fb_destroy_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        fb_destroy_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="destroy"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ui_only | -u)

        # :flag.case_no_arg
        args['--ui_only']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['ticket']+x} ]]; then
          args['ticket']=$1
          shift
        # :argument.case
        elif [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['ticket']+x} ]]; then
    printf "missing required argument: TICKET\nusage: fb destroy TICKET NAME [OPTIONS]\n" >&2
    exit 1
  fi
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: fb destroy TICKET NAME [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
fb_run_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        fb_run_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="run"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ui_only | -u)

        # :flag.case_no_arg
        args['--ui_only']=1
        shift
        ;;

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        # :argument.case
        if [[ -z ${args['target']+x} ]]; then
          args['target']=$1
          shift
        else
          other_args+=("$1")
          shift
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['target']+x} ]]; then
    printf "missing required argument: TARGET\nusage: fb run TARGET [OPTIONS] [...]\n" >&2
    exit 1
  fi

  # :command.whitelist_filter
  if [[ -n ${args['target']:-} ]] && [[ ! ${args['target']:-} =~ ^(app|pipeline)$ ]]; then
    printf "%s\n" "target must be one of: app, pipeline" >&2
    exit 1
  fi

}

# :command.parse_requirements
fb_hotswap_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        fb_hotswap_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="hotswap"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ui_only | -u)

        # :flag.case_no_arg
        args['--ui_only']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.0"
  long_usage=''
  set -e

  # src/initialize.sh

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "branch") fb_branch_command ;;
    "deploy") fb_deploy_command ;;
    "bootstrap") fb_bootstrap_command ;;
    "markdown") fb_markdown_command ;;
    "desc") fb_desc_command ;;
    "destroy") fb_destroy_command ;;
    "run") fb_run_command ;;
    "hotswap") fb_hotswap_command ;;
  esac
}

initialize
run "$@"
